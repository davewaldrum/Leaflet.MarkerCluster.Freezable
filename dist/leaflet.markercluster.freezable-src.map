{"version":3,"file":"leaflet.markercluster.freezable-src.js","sources":["src/freezable.js"],"sourcesContent":["L.MarkerClusterGroup.include({\n\n\t_originalOnAddFreezable: L.MarkerClusterGroup.prototype.onAdd,\n\n\tonAdd: function (map) {\n\t\tvar frozenZoom = this._zoom;\n\n\t\tthis._originalOnAddFreezable(map);\n\n\t\tif (this._frozen) {\n\n\t\t\t// Restore the specified frozenZoom if necessary.\n\t\t\tif (frozenZoom >= 0 && frozenZoom !== this._zoom) {\n\t\t\t\t// Undo clusters and markers addition to this._featureGroup.\n\t\t\t\tthis._featureGroup.clearLayers();\n\n\t\t\t\tthis._zoom = frozenZoom;\n\n\t\t\t\tthis.addLayers([]);\n\t\t\t}\n\n\t\t\t// Replace the callbacks on zoomend and moveend events.\n\t\t\tmap.off('zoomend', this._zoomEnd, this);\n\t\t\tmap.off('moveend', this._moveEnd, this);\n\t\t\tmap.on('zoomend moveend', this._viewChangeEndNotClustering, this);\n\t\t}\n\t},\n\n\t_originalOnRemove: L.MarkerClusterGroup.prototype.onRemove,\n\n\tonRemove: function (map) {\n\t\tmap.off('zoomend moveend', this._viewChangeEndNotClustering, this);\n\t\tthis._originalOnRemove(map);\n\t},\n\n\tdisableClustering: function () {\n\t\treturn this.freezeAtZoom(this._maxZoom + 1);\n\t},\n\n\tdisableClusteringKeepSpiderfy: function () {\n\t\treturn this.freezeAtZoom(this._maxZoom);\n\t},\n\n\tenableClustering: function () {\n\t\treturn this.unfreeze();\n\t},\n\n\tunfreeze: function () {\n\t\treturn this.freezeAtZoom(false);\n\t},\n\n\tfreezeAtZoom: function (frozenZoom) {\n\t\tthis._processQueue();\n\n\t\tvar map = this._map;\n\n\t\t// If frozenZoom is not specified, true or NaN, freeze at current zoom.\n\t\t// Note: NaN is the only value which is not eaqual to itself.\n\t\tif (frozenZoom === undefined || frozenZoom === true || (frozenZoom !== frozenZoom)) {\n\t\t\t// Set to -1 if not on map, as the sign to freeze as soon as it gets added to a map.\n\t\t\tfrozenZoom = map ? Math.round(map.getZoom()) : -1;\n\t\t} else if (frozenZoom === 'max') {\n\t\t\t// If frozenZoom is \"max\", freeze at MCG maxZoom + 1 (eliminates all clusters).\n\t\t\tfrozenZoom = this._maxZoom + 1;\n\t\t} else if (frozenZoom === 'maxKeepSpiderfy') {\n\t\t\t// If \"maxKeepSpiderfy\", freeze at MCG maxZoom (eliminates all clusters but bottom-most ones).\n\t\t\tfrozenZoom = this._maxZoom;\n\t\t}\n\n\t\tvar requestFreezing = typeof frozenZoom === 'number';\n\n\t\tif (this._frozen) { // Already frozen.\n\t\t\tif (!requestFreezing) { // Unfreeze.\n\t\t\t\tthis._unfreeze();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// Just change the frozen zoom: go straight to artificial zoom.\n\t\t} else if (requestFreezing) {\n\t\t\t// Start freezing\n\t\t\tthis._initiateFreeze();\n\t\t} else { // Not frozen and not requesting freezing => nothing to do.\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._artificialZoomSafe(this._zoom, frozenZoom);\n\t\treturn this;\n\t},\n\n\t_initiateFreeze: function () {\n\t\tvar map = this._map;\n\n\t\t// Start freezing\n\t\tthis._frozen = true;\n\n\t\tif (map) {\n\t\t\t// Change behaviour on zoomEnd and moveEnd.\n\t\t\tmap.off('zoomend', this._zoomEnd, this);\n\t\t\tmap.off('moveend', this._moveEnd, this);\n\n\t\t\tmap.on('zoomend moveend', this._viewChangeEndNotClustering, this);\n\t\t}\n\t},\n\n\t_unfreeze: function () {\n\t\tvar map = this._map;\n\n\t\tthis._frozen = false;\n\n\t\tif (map) {\n\t\t\t// Restore original behaviour on zoomEnd.\n\t\t\tmap.off('zoomend moveend', this._viewChangeEndNotClustering, this);\n\n\t\t\tmap.on('zoomend', this._zoomEnd, this);\n\t\t\tmap.on('moveend', this._moveEnd, this);\n\n\t\t\t// Animate.\n\t\t\tthis._executeAfterUnspiderfy(function () {\n\t\t\t\tthis._zoomEnd(); // Will set this._zoom at the end.\n\t\t\t}, this);\n\t\t}\n\t},\n\n\t_executeAfterUnspiderfy: function (callback, context) {\n\t\t// Take care of spiderfied markers!\n\t\t// The cluster might be removed, whereas markers are on fake positions.\n\t\tif (this._unspiderfy && this._spiderfied) {\n\t\t\tthis.once('animationend', function () {\n\t\t\t\tcallback.call(context);\n\t\t\t});\n\t\t\tthis._unspiderfy();\n\t\t\treturn;\n\t\t}\n\n\t\tcallback.call(context);\n\t},\n\n\t_artificialZoomSafe: function (previousZoom, targetZoom) {\n\t\tthis._zoom = targetZoom;\n\n\t\tif (!this._map || previousZoom === targetZoom) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._executeAfterUnspiderfy(function () {\n\t\t\tthis._artificialZoom(previousZoom, targetZoom);\n\t\t}, this);\n\t},\n\n\t_artificialZoom: function (previousZoom, targetZoom) {\n\t\tif (previousZoom < targetZoom) {\n\t\t\t// Make as if we had instantly zoomed in from previousZoom to targetZoom.\n\t\t\tthis._animationStart();\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(\n\t\t\t\tthis._currentShownBounds,\n\t\t\t\tthis._map.getMinZoom(), // New 2nd argument added in Leaflet.markercluster 1.0.4\n\t\t\t\tpreviousZoom,\n\t\t\t\tthis._getExpandedVisibleBounds()\n\t\t\t);\n\t\t\tthis._animationZoomIn(previousZoom, targetZoom);\n\n\t\t} else if (previousZoom > targetZoom) {\n\t\t\t// Make as if we had instantly zoomed out from previousZoom to targetZoom.\n\t\t\tthis._animationStart();\n\t\t\tthis._animationZoomOut(previousZoom, targetZoom);\n\t\t}\n\t},\n\n\t_viewChangeEndNotClustering: function () {\n\t\tvar fg = this._featureGroup,\n\t\t    newBounds = this._getExpandedVisibleBounds(),\n\t\t    targetZoom = this._zoom;\n\n\t\t// Remove markers and bottom clusters outside newBounds, unless they come\n\t\t// from a spiderfied cluster.\n\t\tfg.eachLayer(function (layer) {\n\t\t\tif (!newBounds.contains(layer._latlng) && layer.__parent && layer.__parent._zoom < targetZoom) {\n\t\t\t\tfg.removeLayer(layer);\n\t\t\t}\n\t\t});\n\n\t\t// Add markers and bottom clusters in newBounds.\n\t\tthis._topClusterLevel._recursively(newBounds, -1, targetZoom,\n\t\t\tfunction (c) { // Add markers from each cluster of lower zoom than targetZoom\n\t\t\t\tif (c._zoom === targetZoom) { // except targetZoom\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar markers = c._markers,\n\t\t\t\t    i = 0,\n\t\t\t\t    marker;\n\n\t\t\t\tfor (; i < markers.length; i++) {\n\t\t\t\t\tmarker = c._markers[i];\n\n\t\t\t\t\tif (!newBounds.contains(marker._latlng)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfg.addLayer(marker);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) { // Add clusters from targetZoom.\n\t\t\t\tc._addToMap();\n\t\t\t}\n\t\t);\n\n\t\t// Record new bounds so that newly added markers are properly displayed.\n\t\tthis._currentShownBounds = newBounds;\n\t},\n\n\t_originalZoomOrSpiderfy: L.MarkerClusterGroup.prototype._zoomOrSpiderfy,\n\n\t_zoomOrSpiderfy: function (e) {\n\t\tif (this._frozen && this.options.spiderfyOnMaxZoom) {\n\t\t\te.layer.spiderfy();\n\t\t\tif (e.originalEvent && e.originalEvent.keyCode === 13) {\n\t\t\t\tmap._container.focus();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._originalZoomOrSpiderfy(e);\n\t\t}\n\t}\n\n});\n\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,;;"}